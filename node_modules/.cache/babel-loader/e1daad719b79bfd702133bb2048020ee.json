{"ast":null,"code":"import _regeneratorRuntime from \"/home/runner/work/azureml-network-playbook/azureml-network-playbook/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _objectSpread from \"/home/runner/work/azureml-network-playbook/azureml-network-playbook/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _asyncToGenerator from \"/home/runner/work/azureml-network-playbook/azureml-network-playbook/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport BottleneckLight from 'bottleneck/light';\nvar VERSION = \"3.4.1\";\n\nvar noop = function noop() {\n  return Promise.resolve();\n}; // @ts-ignore\n\n\nfunction wrapRequest(state, request, options) {\n  return state.retryLimiter.schedule(doRequest, state, request, options);\n} // @ts-ignore\n\n\nfunction doRequest(_x, _x2, _x3) {\n  return _doRequest.apply(this, arguments);\n}\n\nfunction _doRequest() {\n  _doRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(state, request, options) {\n    var isWrite, isSearch, isGraphQL, retryCount, jobOptions, req, res, error;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            isWrite = options.method !== \"GET\" && options.method !== \"HEAD\";\n            isSearch = options.method === \"GET\" && options.url.startsWith(\"/search/\");\n            isGraphQL = options.url.startsWith(\"/graphql\");\n            retryCount = ~~options.request.retryCount;\n            jobOptions = retryCount > 0 ? {\n              priority: 0,\n              weight: 0\n            } : {};\n\n            if (state.clustering) {\n              // Remove a job from Redis if it has not completed or failed within 60s\n              // Examples: Node process terminated, client disconnected, etc.\n              // @ts-ignore\n              jobOptions.expiration = 1000 * 60;\n            } // Guarantee at least 1000ms between writes\n            // GraphQL can also trigger writes\n\n\n            if (!(isWrite || isGraphQL)) {\n              _context3.next = 9;\n              break;\n            }\n\n            _context3.next = 9;\n            return state.write.key(state.id).schedule(jobOptions, noop);\n\n          case 9:\n            if (!(isWrite && state.triggersNotification(options.url))) {\n              _context3.next = 12;\n              break;\n            }\n\n            _context3.next = 12;\n            return state.notifications.key(state.id).schedule(jobOptions, noop);\n\n          case 12:\n            if (!isSearch) {\n              _context3.next = 15;\n              break;\n            }\n\n            _context3.next = 15;\n            return state.search.key(state.id).schedule(jobOptions, noop);\n\n          case 15:\n            req = state.global.key(state.id).schedule(jobOptions, request, options);\n\n            if (!isGraphQL) {\n              _context3.next = 23;\n              break;\n            }\n\n            _context3.next = 19;\n            return req;\n\n          case 19:\n            res = _context3.sent;\n\n            if (!(res.data.errors != null && // @ts-ignore\n            res.data.errors.some(function (error) {\n              return error.type === \"RATE_LIMITED\";\n            }))) {\n              _context3.next = 23;\n              break;\n            }\n\n            error = Object.assign(new Error(\"GraphQL Rate Limit Exceeded\"), {\n              headers: res.headers,\n              data: res.data\n            });\n            throw error;\n\n          case 23:\n            return _context3.abrupt(\"return\", req);\n\n          case 24:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _doRequest.apply(this, arguments);\n}\n\nvar triggersNotificationPaths = [\"/orgs/{org}/invitations\", \"/orgs/{org}/invitations/{invitation_id}\", \"/orgs/{org}/teams/{team_slug}/discussions\", \"/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\", \"/repos/{owner}/{repo}/collaborators/{username}\", \"/repos/{owner}/{repo}/commits/{commit_sha}/comments\", \"/repos/{owner}/{repo}/issues\", \"/repos/{owner}/{repo}/issues/{issue_number}/comments\", \"/repos/{owner}/{repo}/pulls\", \"/repos/{owner}/{repo}/pulls/{pull_number}/comments\", \"/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies\", \"/repos/{owner}/{repo}/pulls/{pull_number}/merge\", \"/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\", \"/repos/{owner}/{repo}/pulls/{pull_number}/reviews\", \"/repos/{owner}/{repo}/releases\", \"/teams/{team_id}/discussions\", \"/teams/{team_id}/discussions/{discussion_number}/comments\"]; // @ts-ignore\n\nfunction routeMatcher(paths) {\n  // EXAMPLE. For the following paths:\n\n  /* [\n      \"/orgs/{org}/invitations\",\n      \"/repos/{owner}/{repo}/collaborators/{username}\"\n  ] */\n  // @ts-ignore\n  var regexes = paths.map(function (path) {\n    return path.split(\"/\") // @ts-ignore\n    .map(function (c) {\n      return c.startsWith(\"{\") ? \"(?:.+?)\" : c;\n    }).join(\"/\");\n  }); // 'regexes' would contain:\n\n  /* [\n      '/orgs/(?:.+?)/invitations',\n      '/repos/(?:.+?)/(?:.+?)/collaborators/(?:.+?)'\n  ] */\n  // @ts-ignore\n\n  var regex = \"^(?:\".concat(regexes.map(function (r) {\n    return \"(?:\".concat(r, \")\");\n  }).join(\"|\"), \")[^/]*$\"); // 'regex' would contain:\n\n  /*\n    ^(?:(?:\\/orgs\\/(?:.+?)\\/invitations)|(?:\\/repos\\/(?:.+?)\\/(?:.+?)\\/collaborators\\/(?:.+?)))[^\\/]*$\n       It may look scary, but paste it into https://www.debuggex.com/\n    and it will make a lot more sense!\n  */\n\n  return new RegExp(regex, \"i\");\n} // @ts-ignore\n// Workaround to allow tests to directly access the triggersNotification function.\n\n\nvar regex = routeMatcher(triggersNotificationPaths);\nvar triggersNotification = regex.test.bind(regex);\nvar groups = {}; // @ts-ignore\n\nvar createGroups = function createGroups(Bottleneck, common) {\n  // @ts-ignore\n  groups.global = new Bottleneck.Group(_objectSpread({\n    id: \"octokit-global\",\n    maxConcurrent: 10\n  }, common)); // @ts-ignore\n\n  groups.search = new Bottleneck.Group(_objectSpread({\n    id: \"octokit-search\",\n    maxConcurrent: 1,\n    minTime: 2000\n  }, common)); // @ts-ignore\n\n  groups.write = new Bottleneck.Group(_objectSpread({\n    id: \"octokit-write\",\n    maxConcurrent: 1,\n    minTime: 1000\n  }, common)); // @ts-ignore\n\n  groups.notifications = new Bottleneck.Group(_objectSpread({\n    id: \"octokit-notifications\",\n    maxConcurrent: 1,\n    minTime: 3000\n  }, common));\n};\n\nfunction throttling(octokit) {\n  var octokitOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _ref = octokitOptions.throttle || {},\n      _ref$enabled = _ref.enabled,\n      enabled = _ref$enabled === void 0 ? true : _ref$enabled,\n      _ref$Bottleneck = _ref.Bottleneck,\n      Bottleneck = _ref$Bottleneck === void 0 ? BottleneckLight : _ref$Bottleneck,\n      _ref$id = _ref.id,\n      id = _ref$id === void 0 ? \"no-id\" : _ref$id,\n      _ref$timeout = _ref.timeout,\n      timeout = _ref$timeout === void 0 ? 1000 * 60 * 2 : _ref$timeout,\n      connection = _ref.connection;\n\n  if (!enabled) {\n    return;\n  }\n\n  var common = {\n    connection: connection,\n    timeout: timeout\n  }; // @ts-ignore\n\n  if (groups.global == null) {\n    createGroups(Bottleneck, common);\n  }\n\n  var state = Object.assign(_objectSpread({\n    clustering: connection != null,\n    triggersNotification: triggersNotification,\n    minimumAbuseRetryAfter: 5,\n    retryAfterBaseValue: 1000,\n    retryLimiter: new Bottleneck(),\n    id: id\n  }, groups), // @ts-ignore\n  octokitOptions.throttle);\n\n  if (typeof state.onAbuseLimit !== \"function\" || typeof state.onRateLimit !== \"function\") {\n    throw new Error(\"octokit/plugin-throttling error:\\n        You must pass the onAbuseLimit and onRateLimit error handlers.\\n        See https://github.com/octokit/rest.js#throttling\\n\\n        const octokit = new Octokit({\\n          throttle: {\\n            onAbuseLimit: (retryAfter, options) => {/* ... */},\\n            onRateLimit: (retryAfter, options) => {/* ... */}\\n          }\\n        })\\n    \");\n  }\n\n  var events = {};\n  var emitter = new Bottleneck.Events(events); // @ts-ignore\n\n  events.on(\"abuse-limit\", state.onAbuseLimit); // @ts-ignore\n\n  events.on(\"rate-limit\", state.onRateLimit); // @ts-ignore\n\n  events.on(\"error\", function (e) {\n    return console.warn(\"Error in throttling-plugin limit handler\", e);\n  }); // @ts-ignore\n\n  state.retryLimiter.on(\"failed\", /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(error, info) {\n      var options, shouldRetryGraphQL, retryCount, _yield, wantRetry, retryAfter;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = info.args[info.args.length - 1];\n              shouldRetryGraphQL = options.url.startsWith(\"/graphql\") && error.status !== 401;\n\n              if (shouldRetryGraphQL || error.status === 403) {\n                _context2.next = 4;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 4:\n              retryCount = ~~options.request.retryCount;\n              options.request.retryCount = retryCount;\n              _context2.next = 8;\n              return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                var _retryAfter, _wantRetry, rateLimitReset, _retryAfter2, _wantRetry2;\n\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        if (!/\\babuse\\b/i.test(error.message)) {\n                          _context.next = 6;\n                          break;\n                        }\n\n                        // The user has hit the abuse rate limit. (REST and GraphQL)\n                        // https://docs.github.com/en/rest/overview/resources-in-the-rest-api#abuse-rate-limits\n                        // The Retry-After header can sometimes be blank when hitting an abuse limit,\n                        // but is always present after 2-3s, so make sure to set `retryAfter` to at least 5s by default.\n                        _retryAfter = Math.max(~~error.headers[\"retry-after\"], state.minimumAbuseRetryAfter);\n                        _context.next = 4;\n                        return emitter.trigger(\"abuse-limit\", _retryAfter, options, octokit);\n\n                      case 4:\n                        _wantRetry = _context.sent;\n                        return _context.abrupt(\"return\", {\n                          wantRetry: _wantRetry,\n                          retryAfter: _retryAfter\n                        });\n\n                      case 6:\n                        if (!(error.headers != null && error.headers[\"x-ratelimit-remaining\"] === \"0\")) {\n                          _context.next = 13;\n                          break;\n                        }\n\n                        // The user has used all their allowed calls for the current time period (REST and GraphQL)\n                        // https://docs.github.com/en/rest/reference/rate-limit (REST)\n                        // https://docs.github.com/en/graphql/overview/resource-limitations#rate-limit (GraphQL)\n                        rateLimitReset = new Date(~~error.headers[\"x-ratelimit-reset\"] * 1000).getTime();\n                        _retryAfter2 = Math.max(Math.ceil((rateLimitReset - Date.now()) / 1000), 0);\n                        _context.next = 11;\n                        return emitter.trigger(\"rate-limit\", _retryAfter2, options, octokit);\n\n                      case 11:\n                        _wantRetry2 = _context.sent;\n                        return _context.abrupt(\"return\", {\n                          wantRetry: _wantRetry2,\n                          retryAfter: _retryAfter2\n                        });\n\n                      case 13:\n                        return _context.abrupt(\"return\", {});\n\n                      case 14:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }))();\n\n            case 8:\n              _yield = _context2.sent;\n              wantRetry = _yield.wantRetry;\n              retryAfter = _yield.retryAfter;\n\n              if (!wantRetry) {\n                _context2.next = 14;\n                break;\n              }\n\n              options.request.retryCount++; // @ts-ignore\n\n              return _context2.abrupt(\"return\", retryAfter * state.retryAfterBaseValue);\n\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x4, _x5) {\n      return _ref2.apply(this, arguments);\n    };\n  }());\n  octokit.hook.wrap(\"request\", wrapRequest.bind(null, state));\n}\n\nthrottling.VERSION = VERSION;\nthrottling.triggersNotification = triggersNotification;\nexport { throttling };","map":{"version":3,"sources":["../dist-src/version.js","../dist-src/wrap-request.js","../dist-src/generated/triggers-notification-paths.js","../dist-src/route-matcher.js","../dist-src/index.js"],"names":[],"mappings":"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","sourcesContent":["export const VERSION = \"3.4.1\";\n","const noop = () => Promise.resolve();\n// @ts-ignore\nexport function wrapRequest(state, request, options) {\n    return state.retryLimiter.schedule(doRequest, state, request, options);\n}\n// @ts-ignore\nasync function doRequest(state, request, options) {\n    const isWrite = options.method !== \"GET\" && options.method !== \"HEAD\";\n    const isSearch = options.method === \"GET\" && options.url.startsWith(\"/search/\");\n    const isGraphQL = options.url.startsWith(\"/graphql\");\n    const retryCount = ~~options.request.retryCount;\n    const jobOptions = retryCount > 0 ? { priority: 0, weight: 0 } : {};\n    if (state.clustering) {\n        // Remove a job from Redis if it has not completed or failed within 60s\n        // Examples: Node process terminated, client disconnected, etc.\n        // @ts-ignore\n        jobOptions.expiration = 1000 * 60;\n    }\n    // Guarantee at least 1000ms between writes\n    // GraphQL can also trigger writes\n    if (isWrite || isGraphQL) {\n        await state.write.key(state.id).schedule(jobOptions, noop);\n    }\n    // Guarantee at least 3000ms between requests that trigger notifications\n    if (isWrite && state.triggersNotification(options.url)) {\n        await state.notifications.key(state.id).schedule(jobOptions, noop);\n    }\n    // Guarantee at least 2000ms between search requests\n    if (isSearch) {\n        await state.search.key(state.id).schedule(jobOptions, noop);\n    }\n    const req = state.global.key(state.id).schedule(jobOptions, request, options);\n    if (isGraphQL) {\n        const res = await req;\n        if (res.data.errors != null &&\n            // @ts-ignore\n            res.data.errors.some((error) => error.type === \"RATE_LIMITED\")) {\n            const error = Object.assign(new Error(\"GraphQL Rate Limit Exceeded\"), {\n                headers: res.headers,\n                data: res.data,\n            });\n            throw error;\n        }\n    }\n    return req;\n}\n","export default [\n    \"/orgs/{org}/invitations\",\n    \"/orgs/{org}/invitations/{invitation_id}\",\n    \"/orgs/{org}/teams/{team_slug}/discussions\",\n    \"/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\",\n    \"/repos/{owner}/{repo}/collaborators/{username}\",\n    \"/repos/{owner}/{repo}/commits/{commit_sha}/comments\",\n    \"/repos/{owner}/{repo}/issues\",\n    \"/repos/{owner}/{repo}/issues/{issue_number}/comments\",\n    \"/repos/{owner}/{repo}/pulls\",\n    \"/repos/{owner}/{repo}/pulls/{pull_number}/comments\",\n    \"/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies\",\n    \"/repos/{owner}/{repo}/pulls/{pull_number}/merge\",\n    \"/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\",\n    \"/repos/{owner}/{repo}/pulls/{pull_number}/reviews\",\n    \"/repos/{owner}/{repo}/releases\",\n    \"/teams/{team_id}/discussions\",\n    \"/teams/{team_id}/discussions/{discussion_number}/comments\",\n];\n","// @ts-ignore\nexport function routeMatcher(paths) {\n    // EXAMPLE. For the following paths:\n    /* [\n        \"/orgs/{org}/invitations\",\n        \"/repos/{owner}/{repo}/collaborators/{username}\"\n    ] */\n    // @ts-ignore\n    const regexes = paths.map((path) => path\n        .split(\"/\")\n        // @ts-ignore\n        .map((c) => (c.startsWith(\"{\") ? \"(?:.+?)\" : c))\n        .join(\"/\"));\n    // 'regexes' would contain:\n    /* [\n        '/orgs/(?:.+?)/invitations',\n        '/repos/(?:.+?)/(?:.+?)/collaborators/(?:.+?)'\n    ] */\n    // @ts-ignore\n    const regex = `^(?:${regexes.map((r) => `(?:${r})`).join(\"|\")})[^/]*$`;\n    // 'regex' would contain:\n    /*\n      ^(?:(?:\\/orgs\\/(?:.+?)\\/invitations)|(?:\\/repos\\/(?:.+?)\\/(?:.+?)\\/collaborators\\/(?:.+?)))[^\\/]*$\n  \n      It may look scary, but paste it into https://www.debuggex.com/\n      and it will make a lot more sense!\n    */\n    return new RegExp(regex, \"i\");\n}\n","// @ts-ignore\nimport BottleneckLight from \"bottleneck/light\";\nimport { VERSION } from \"./version\";\nimport { wrapRequest } from \"./wrap-request\";\nimport triggersNotificationPaths from \"./generated/triggers-notification-paths\";\nimport { routeMatcher } from \"./route-matcher\";\n// Workaround to allow tests to directly access the triggersNotification function.\nconst regex = routeMatcher(triggersNotificationPaths);\nconst triggersNotification = regex.test.bind(regex);\nconst groups = {};\n// @ts-ignore\nconst createGroups = function (Bottleneck, common) {\n    // @ts-ignore\n    groups.global = new Bottleneck.Group({\n        id: \"octokit-global\",\n        maxConcurrent: 10,\n        ...common,\n    });\n    // @ts-ignore\n    groups.search = new Bottleneck.Group({\n        id: \"octokit-search\",\n        maxConcurrent: 1,\n        minTime: 2000,\n        ...common,\n    });\n    // @ts-ignore\n    groups.write = new Bottleneck.Group({\n        id: \"octokit-write\",\n        maxConcurrent: 1,\n        minTime: 1000,\n        ...common,\n    });\n    // @ts-ignore\n    groups.notifications = new Bottleneck.Group({\n        id: \"octokit-notifications\",\n        maxConcurrent: 1,\n        minTime: 3000,\n        ...common,\n    });\n};\nexport function throttling(octokit, octokitOptions = {}) {\n    const { enabled = true, Bottleneck = BottleneckLight, id = \"no-id\", timeout = 1000 * 60 * 2, // Redis TTL: 2 minutes\n    connection, } = octokitOptions.throttle || {};\n    if (!enabled) {\n        return;\n    }\n    const common = { connection, timeout };\n    // @ts-ignore\n    if (groups.global == null) {\n        createGroups(Bottleneck, common);\n    }\n    const state = Object.assign({\n        clustering: connection != null,\n        triggersNotification,\n        minimumAbuseRetryAfter: 5,\n        retryAfterBaseValue: 1000,\n        retryLimiter: new Bottleneck(),\n        id,\n        ...groups,\n    }, \n    // @ts-ignore\n    octokitOptions.throttle);\n    if (typeof state.onAbuseLimit !== \"function\" ||\n        typeof state.onRateLimit !== \"function\") {\n        throw new Error(`octokit/plugin-throttling error:\n        You must pass the onAbuseLimit and onRateLimit error handlers.\n        See https://github.com/octokit/rest.js#throttling\n\n        const octokit = new Octokit({\n          throttle: {\n            onAbuseLimit: (retryAfter, options) => {/* ... */},\n            onRateLimit: (retryAfter, options) => {/* ... */}\n          }\n        })\n    `);\n    }\n    const events = {};\n    const emitter = new Bottleneck.Events(events);\n    // @ts-ignore\n    events.on(\"abuse-limit\", state.onAbuseLimit);\n    // @ts-ignore\n    events.on(\"rate-limit\", state.onRateLimit);\n    // @ts-ignore\n    events.on(\"error\", (e) => console.warn(\"Error in throttling-plugin limit handler\", e));\n    // @ts-ignore\n    state.retryLimiter.on(\"failed\", async function (error, info) {\n        const options = info.args[info.args.length - 1];\n        const shouldRetryGraphQL = options.url.startsWith(\"/graphql\") && error.status !== 401;\n        if (!(shouldRetryGraphQL || error.status === 403)) {\n            return;\n        }\n        const retryCount = ~~options.request.retryCount;\n        options.request.retryCount = retryCount;\n        const { wantRetry, retryAfter } = await (async function () {\n            if (/\\babuse\\b/i.test(error.message)) {\n                // The user has hit the abuse rate limit. (REST and GraphQL)\n                // https://docs.github.com/en/rest/overview/resources-in-the-rest-api#abuse-rate-limits\n                // The Retry-After header can sometimes be blank when hitting an abuse limit,\n                // but is always present after 2-3s, so make sure to set `retryAfter` to at least 5s by default.\n                const retryAfter = Math.max(~~error.headers[\"retry-after\"], state.minimumAbuseRetryAfter);\n                const wantRetry = await emitter.trigger(\"abuse-limit\", retryAfter, options, octokit);\n                return { wantRetry, retryAfter };\n            }\n            if (error.headers != null &&\n                error.headers[\"x-ratelimit-remaining\"] === \"0\") {\n                // The user has used all their allowed calls for the current time period (REST and GraphQL)\n                // https://docs.github.com/en/rest/reference/rate-limit (REST)\n                // https://docs.github.com/en/graphql/overview/resource-limitations#rate-limit (GraphQL)\n                const rateLimitReset = new Date(~~error.headers[\"x-ratelimit-reset\"] * 1000).getTime();\n                const retryAfter = Math.max(Math.ceil((rateLimitReset - Date.now()) / 1000), 0);\n                const wantRetry = await emitter.trigger(\"rate-limit\", retryAfter, options, octokit);\n                return { wantRetry, retryAfter };\n            }\n            return {};\n        })();\n        if (wantRetry) {\n            options.request.retryCount++;\n            // @ts-ignore\n            return retryAfter * state.retryAfterBaseValue;\n        }\n    });\n    octokit.hook.wrap(\"request\", wrapRequest.bind(null, state));\n}\nthrottling.VERSION = VERSION;\nthrottling.triggersNotification = triggersNotification;\n"]},"metadata":{},"sourceType":"module"}