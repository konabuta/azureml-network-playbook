{"ast":null,"code":"import BottleneckLight from 'bottleneck/light';\nconst VERSION = \"3.4.1\";\n\nconst noop = () => Promise.resolve(); // @ts-ignore\n\n\nfunction wrapRequest(state, request, options) {\n  return state.retryLimiter.schedule(doRequest, state, request, options);\n} // @ts-ignore\n\n\nasync function doRequest(state, request, options) {\n  const isWrite = options.method !== \"GET\" && options.method !== \"HEAD\";\n  const isSearch = options.method === \"GET\" && options.url.startsWith(\"/search/\");\n  const isGraphQL = options.url.startsWith(\"/graphql\");\n  const retryCount = ~~options.request.retryCount;\n  const jobOptions = retryCount > 0 ? {\n    priority: 0,\n    weight: 0\n  } : {};\n\n  if (state.clustering) {\n    // Remove a job from Redis if it has not completed or failed within 60s\n    // Examples: Node process terminated, client disconnected, etc.\n    // @ts-ignore\n    jobOptions.expiration = 1000 * 60;\n  } // Guarantee at least 1000ms between writes\n  // GraphQL can also trigger writes\n\n\n  if (isWrite || isGraphQL) {\n    await state.write.key(state.id).schedule(jobOptions, noop);\n  } // Guarantee at least 3000ms between requests that trigger notifications\n\n\n  if (isWrite && state.triggersNotification(options.url)) {\n    await state.notifications.key(state.id).schedule(jobOptions, noop);\n  } // Guarantee at least 2000ms between search requests\n\n\n  if (isSearch) {\n    await state.search.key(state.id).schedule(jobOptions, noop);\n  }\n\n  const req = state.global.key(state.id).schedule(jobOptions, request, options);\n\n  if (isGraphQL) {\n    const res = await req;\n\n    if (res.data.errors != null && // @ts-ignore\n    res.data.errors.some(error => error.type === \"RATE_LIMITED\")) {\n      const error = Object.assign(new Error(\"GraphQL Rate Limit Exceeded\"), {\n        headers: res.headers,\n        data: res.data\n      });\n      throw error;\n    }\n  }\n\n  return req;\n}\n\nvar triggersNotificationPaths = [\"/orgs/{org}/invitations\", \"/orgs/{org}/invitations/{invitation_id}\", \"/orgs/{org}/teams/{team_slug}/discussions\", \"/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\", \"/repos/{owner}/{repo}/collaborators/{username}\", \"/repos/{owner}/{repo}/commits/{commit_sha}/comments\", \"/repos/{owner}/{repo}/issues\", \"/repos/{owner}/{repo}/issues/{issue_number}/comments\", \"/repos/{owner}/{repo}/pulls\", \"/repos/{owner}/{repo}/pulls/{pull_number}/comments\", \"/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies\", \"/repos/{owner}/{repo}/pulls/{pull_number}/merge\", \"/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\", \"/repos/{owner}/{repo}/pulls/{pull_number}/reviews\", \"/repos/{owner}/{repo}/releases\", \"/teams/{team_id}/discussions\", \"/teams/{team_id}/discussions/{discussion_number}/comments\"]; // @ts-ignore\n\nfunction routeMatcher(paths) {\n  // EXAMPLE. For the following paths:\n\n  /* [\n      \"/orgs/{org}/invitations\",\n      \"/repos/{owner}/{repo}/collaborators/{username}\"\n  ] */\n  // @ts-ignore\n  const regexes = paths.map(path => path.split(\"/\") // @ts-ignore\n  .map(c => c.startsWith(\"{\") ? \"(?:.+?)\" : c).join(\"/\")); // 'regexes' would contain:\n\n  /* [\n      '/orgs/(?:.+?)/invitations',\n      '/repos/(?:.+?)/(?:.+?)/collaborators/(?:.+?)'\n  ] */\n  // @ts-ignore\n\n  const regex = `^(?:${regexes.map(r => `(?:${r})`).join(\"|\")})[^/]*$`; // 'regex' would contain:\n\n  /*\n    ^(?:(?:\\/orgs\\/(?:.+?)\\/invitations)|(?:\\/repos\\/(?:.+?)\\/(?:.+?)\\/collaborators\\/(?:.+?)))[^\\/]*$\n       It may look scary, but paste it into https://www.debuggex.com/\n    and it will make a lot more sense!\n  */\n\n  return new RegExp(regex, \"i\");\n} // @ts-ignore\n// Workaround to allow tests to directly access the triggersNotification function.\n\n\nconst regex = routeMatcher(triggersNotificationPaths);\nconst triggersNotification = regex.test.bind(regex);\nconst groups = {}; // @ts-ignore\n\nconst createGroups = function (Bottleneck, common) {\n  // @ts-ignore\n  groups.global = new Bottleneck.Group({\n    id: \"octokit-global\",\n    maxConcurrent: 10,\n    ...common\n  }); // @ts-ignore\n\n  groups.search = new Bottleneck.Group({\n    id: \"octokit-search\",\n    maxConcurrent: 1,\n    minTime: 2000,\n    ...common\n  }); // @ts-ignore\n\n  groups.write = new Bottleneck.Group({\n    id: \"octokit-write\",\n    maxConcurrent: 1,\n    minTime: 1000,\n    ...common\n  }); // @ts-ignore\n\n  groups.notifications = new Bottleneck.Group({\n    id: \"octokit-notifications\",\n    maxConcurrent: 1,\n    minTime: 3000,\n    ...common\n  });\n};\n\nfunction throttling(octokit, octokitOptions = {}) {\n  const {\n    enabled = true,\n    Bottleneck = BottleneckLight,\n    id = \"no-id\",\n    timeout = 1000 * 60 * 2,\n    // Redis TTL: 2 minutes\n    connection\n  } = octokitOptions.throttle || {};\n\n  if (!enabled) {\n    return;\n  }\n\n  const common = {\n    connection,\n    timeout\n  }; // @ts-ignore\n\n  if (groups.global == null) {\n    createGroups(Bottleneck, common);\n  }\n\n  const state = Object.assign({\n    clustering: connection != null,\n    triggersNotification,\n    minimumAbuseRetryAfter: 5,\n    retryAfterBaseValue: 1000,\n    retryLimiter: new Bottleneck(),\n    id,\n    ...groups\n  }, // @ts-ignore\n  octokitOptions.throttle);\n\n  if (typeof state.onAbuseLimit !== \"function\" || typeof state.onRateLimit !== \"function\") {\n    throw new Error(`octokit/plugin-throttling error:\n        You must pass the onAbuseLimit and onRateLimit error handlers.\n        See https://github.com/octokit/rest.js#throttling\n\n        const octokit = new Octokit({\n          throttle: {\n            onAbuseLimit: (retryAfter, options) => {/* ... */},\n            onRateLimit: (retryAfter, options) => {/* ... */}\n          }\n        })\n    `);\n  }\n\n  const events = {};\n  const emitter = new Bottleneck.Events(events); // @ts-ignore\n\n  events.on(\"abuse-limit\", state.onAbuseLimit); // @ts-ignore\n\n  events.on(\"rate-limit\", state.onRateLimit); // @ts-ignore\n\n  events.on(\"error\", e => console.warn(\"Error in throttling-plugin limit handler\", e)); // @ts-ignore\n\n  state.retryLimiter.on(\"failed\", async function (error, info) {\n    const options = info.args[info.args.length - 1];\n    const shouldRetryGraphQL = options.url.startsWith(\"/graphql\") && error.status !== 401;\n\n    if (!(shouldRetryGraphQL || error.status === 403)) {\n      return;\n    }\n\n    const retryCount = ~~options.request.retryCount;\n    options.request.retryCount = retryCount;\n    const {\n      wantRetry,\n      retryAfter\n    } = await async function () {\n      if (/\\babuse\\b/i.test(error.message)) {\n        // The user has hit the abuse rate limit. (REST and GraphQL)\n        // https://docs.github.com/en/rest/overview/resources-in-the-rest-api#abuse-rate-limits\n        // The Retry-After header can sometimes be blank when hitting an abuse limit,\n        // but is always present after 2-3s, so make sure to set `retryAfter` to at least 5s by default.\n        const retryAfter = Math.max(~~error.headers[\"retry-after\"], state.minimumAbuseRetryAfter);\n        const wantRetry = await emitter.trigger(\"abuse-limit\", retryAfter, options, octokit);\n        return {\n          wantRetry,\n          retryAfter\n        };\n      }\n\n      if (error.headers != null && error.headers[\"x-ratelimit-remaining\"] === \"0\") {\n        // The user has used all their allowed calls for the current time period (REST and GraphQL)\n        // https://docs.github.com/en/rest/reference/rate-limit (REST)\n        // https://docs.github.com/en/graphql/overview/resource-limitations#rate-limit (GraphQL)\n        const rateLimitReset = new Date(~~error.headers[\"x-ratelimit-reset\"] * 1000).getTime();\n        const retryAfter = Math.max(Math.ceil((rateLimitReset - Date.now()) / 1000), 0);\n        const wantRetry = await emitter.trigger(\"rate-limit\", retryAfter, options, octokit);\n        return {\n          wantRetry,\n          retryAfter\n        };\n      }\n\n      return {};\n    }();\n\n    if (wantRetry) {\n      options.request.retryCount++; // @ts-ignore\n\n      return retryAfter * state.retryAfterBaseValue;\n    }\n  });\n  octokit.hook.wrap(\"request\", wrapRequest.bind(null, state));\n}\n\nthrottling.VERSION = VERSION;\nthrottling.triggersNotification = triggersNotification;\nexport { throttling };","map":{"version":3,"sources":["../dist-src/version.js","../dist-src/wrap-request.js","../dist-src/generated/triggers-notification-paths.js","../dist-src/route-matcher.js","../dist-src/index.js"],"names":[],"mappings":"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","sourcesContent":["export const VERSION = \"3.4.1\";\n","const noop = () => Promise.resolve();\n// @ts-ignore\nexport function wrapRequest(state, request, options) {\n    return state.retryLimiter.schedule(doRequest, state, request, options);\n}\n// @ts-ignore\nasync function doRequest(state, request, options) {\n    const isWrite = options.method !== \"GET\" && options.method !== \"HEAD\";\n    const isSearch = options.method === \"GET\" && options.url.startsWith(\"/search/\");\n    const isGraphQL = options.url.startsWith(\"/graphql\");\n    const retryCount = ~~options.request.retryCount;\n    const jobOptions = retryCount > 0 ? { priority: 0, weight: 0 } : {};\n    if (state.clustering) {\n        // Remove a job from Redis if it has not completed or failed within 60s\n        // Examples: Node process terminated, client disconnected, etc.\n        // @ts-ignore\n        jobOptions.expiration = 1000 * 60;\n    }\n    // Guarantee at least 1000ms between writes\n    // GraphQL can also trigger writes\n    if (isWrite || isGraphQL) {\n        await state.write.key(state.id).schedule(jobOptions, noop);\n    }\n    // Guarantee at least 3000ms between requests that trigger notifications\n    if (isWrite && state.triggersNotification(options.url)) {\n        await state.notifications.key(state.id).schedule(jobOptions, noop);\n    }\n    // Guarantee at least 2000ms between search requests\n    if (isSearch) {\n        await state.search.key(state.id).schedule(jobOptions, noop);\n    }\n    const req = state.global.key(state.id).schedule(jobOptions, request, options);\n    if (isGraphQL) {\n        const res = await req;\n        if (res.data.errors != null &&\n            // @ts-ignore\n            res.data.errors.some((error) => error.type === \"RATE_LIMITED\")) {\n            const error = Object.assign(new Error(\"GraphQL Rate Limit Exceeded\"), {\n                headers: res.headers,\n                data: res.data,\n            });\n            throw error;\n        }\n    }\n    return req;\n}\n","export default [\n    \"/orgs/{org}/invitations\",\n    \"/orgs/{org}/invitations/{invitation_id}\",\n    \"/orgs/{org}/teams/{team_slug}/discussions\",\n    \"/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\",\n    \"/repos/{owner}/{repo}/collaborators/{username}\",\n    \"/repos/{owner}/{repo}/commits/{commit_sha}/comments\",\n    \"/repos/{owner}/{repo}/issues\",\n    \"/repos/{owner}/{repo}/issues/{issue_number}/comments\",\n    \"/repos/{owner}/{repo}/pulls\",\n    \"/repos/{owner}/{repo}/pulls/{pull_number}/comments\",\n    \"/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies\",\n    \"/repos/{owner}/{repo}/pulls/{pull_number}/merge\",\n    \"/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\",\n    \"/repos/{owner}/{repo}/pulls/{pull_number}/reviews\",\n    \"/repos/{owner}/{repo}/releases\",\n    \"/teams/{team_id}/discussions\",\n    \"/teams/{team_id}/discussions/{discussion_number}/comments\",\n];\n","// @ts-ignore\nexport function routeMatcher(paths) {\n    // EXAMPLE. For the following paths:\n    /* [\n        \"/orgs/{org}/invitations\",\n        \"/repos/{owner}/{repo}/collaborators/{username}\"\n    ] */\n    // @ts-ignore\n    const regexes = paths.map((path) => path\n        .split(\"/\")\n        // @ts-ignore\n        .map((c) => (c.startsWith(\"{\") ? \"(?:.+?)\" : c))\n        .join(\"/\"));\n    // 'regexes' would contain:\n    /* [\n        '/orgs/(?:.+?)/invitations',\n        '/repos/(?:.+?)/(?:.+?)/collaborators/(?:.+?)'\n    ] */\n    // @ts-ignore\n    const regex = `^(?:${regexes.map((r) => `(?:${r})`).join(\"|\")})[^/]*$`;\n    // 'regex' would contain:\n    /*\n      ^(?:(?:\\/orgs\\/(?:.+?)\\/invitations)|(?:\\/repos\\/(?:.+?)\\/(?:.+?)\\/collaborators\\/(?:.+?)))[^\\/]*$\n  \n      It may look scary, but paste it into https://www.debuggex.com/\n      and it will make a lot more sense!\n    */\n    return new RegExp(regex, \"i\");\n}\n","// @ts-ignore\nimport BottleneckLight from \"bottleneck/light\";\nimport { VERSION } from \"./version\";\nimport { wrapRequest } from \"./wrap-request\";\nimport triggersNotificationPaths from \"./generated/triggers-notification-paths\";\nimport { routeMatcher } from \"./route-matcher\";\n// Workaround to allow tests to directly access the triggersNotification function.\nconst regex = routeMatcher(triggersNotificationPaths);\nconst triggersNotification = regex.test.bind(regex);\nconst groups = {};\n// @ts-ignore\nconst createGroups = function (Bottleneck, common) {\n    // @ts-ignore\n    groups.global = new Bottleneck.Group({\n        id: \"octokit-global\",\n        maxConcurrent: 10,\n        ...common,\n    });\n    // @ts-ignore\n    groups.search = new Bottleneck.Group({\n        id: \"octokit-search\",\n        maxConcurrent: 1,\n        minTime: 2000,\n        ...common,\n    });\n    // @ts-ignore\n    groups.write = new Bottleneck.Group({\n        id: \"octokit-write\",\n        maxConcurrent: 1,\n        minTime: 1000,\n        ...common,\n    });\n    // @ts-ignore\n    groups.notifications = new Bottleneck.Group({\n        id: \"octokit-notifications\",\n        maxConcurrent: 1,\n        minTime: 3000,\n        ...common,\n    });\n};\nexport function throttling(octokit, octokitOptions = {}) {\n    const { enabled = true, Bottleneck = BottleneckLight, id = \"no-id\", timeout = 1000 * 60 * 2, // Redis TTL: 2 minutes\n    connection, } = octokitOptions.throttle || {};\n    if (!enabled) {\n        return;\n    }\n    const common = { connection, timeout };\n    // @ts-ignore\n    if (groups.global == null) {\n        createGroups(Bottleneck, common);\n    }\n    const state = Object.assign({\n        clustering: connection != null,\n        triggersNotification,\n        minimumAbuseRetryAfter: 5,\n        retryAfterBaseValue: 1000,\n        retryLimiter: new Bottleneck(),\n        id,\n        ...groups,\n    }, \n    // @ts-ignore\n    octokitOptions.throttle);\n    if (typeof state.onAbuseLimit !== \"function\" ||\n        typeof state.onRateLimit !== \"function\") {\n        throw new Error(`octokit/plugin-throttling error:\n        You must pass the onAbuseLimit and onRateLimit error handlers.\n        See https://github.com/octokit/rest.js#throttling\n\n        const octokit = new Octokit({\n          throttle: {\n            onAbuseLimit: (retryAfter, options) => {/* ... */},\n            onRateLimit: (retryAfter, options) => {/* ... */}\n          }\n        })\n    `);\n    }\n    const events = {};\n    const emitter = new Bottleneck.Events(events);\n    // @ts-ignore\n    events.on(\"abuse-limit\", state.onAbuseLimit);\n    // @ts-ignore\n    events.on(\"rate-limit\", state.onRateLimit);\n    // @ts-ignore\n    events.on(\"error\", (e) => console.warn(\"Error in throttling-plugin limit handler\", e));\n    // @ts-ignore\n    state.retryLimiter.on(\"failed\", async function (error, info) {\n        const options = info.args[info.args.length - 1];\n        const shouldRetryGraphQL = options.url.startsWith(\"/graphql\") && error.status !== 401;\n        if (!(shouldRetryGraphQL || error.status === 403)) {\n            return;\n        }\n        const retryCount = ~~options.request.retryCount;\n        options.request.retryCount = retryCount;\n        const { wantRetry, retryAfter } = await (async function () {\n            if (/\\babuse\\b/i.test(error.message)) {\n                // The user has hit the abuse rate limit. (REST and GraphQL)\n                // https://docs.github.com/en/rest/overview/resources-in-the-rest-api#abuse-rate-limits\n                // The Retry-After header can sometimes be blank when hitting an abuse limit,\n                // but is always present after 2-3s, so make sure to set `retryAfter` to at least 5s by default.\n                const retryAfter = Math.max(~~error.headers[\"retry-after\"], state.minimumAbuseRetryAfter);\n                const wantRetry = await emitter.trigger(\"abuse-limit\", retryAfter, options, octokit);\n                return { wantRetry, retryAfter };\n            }\n            if (error.headers != null &&\n                error.headers[\"x-ratelimit-remaining\"] === \"0\") {\n                // The user has used all their allowed calls for the current time period (REST and GraphQL)\n                // https://docs.github.com/en/rest/reference/rate-limit (REST)\n                // https://docs.github.com/en/graphql/overview/resource-limitations#rate-limit (GraphQL)\n                const rateLimitReset = new Date(~~error.headers[\"x-ratelimit-reset\"] * 1000).getTime();\n                const retryAfter = Math.max(Math.ceil((rateLimitReset - Date.now()) / 1000), 0);\n                const wantRetry = await emitter.trigger(\"rate-limit\", retryAfter, options, octokit);\n                return { wantRetry, retryAfter };\n            }\n            return {};\n        })();\n        if (wantRetry) {\n            options.request.retryCount++;\n            // @ts-ignore\n            return retryAfter * state.retryAfterBaseValue;\n        }\n    });\n    octokit.hook.wrap(\"request\", wrapRequest.bind(null, state));\n}\nthrottling.VERSION = VERSION;\nthrottling.triggersNotification = triggersNotification;\n"]},"metadata":{},"sourceType":"module"}